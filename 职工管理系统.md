







# 职工管理系统

## 1.管理系统需求

职工管理系统可以用来管理公司内所有员工的信息

公司中职工分为三类：普通员工，经理，老板，显示信息时，需要显示职工编号，职工姓名，职工岗位，以及职责
**普通员工**：完成经理交给的任务
**经理职责：**完成老板交给的任务，并下发任务给员工
**老板职责**：管理公司所有事务

管理系统中需要实现的功能如下：

* 退出通讯录：退出当前通讯录系统
* 增加职工信息：实现批量添加职工功能，将信息录入到文件中，职工信息为：职工编号，姓名，部门编号
* 显示职工信息：显示公司内所有职工的信息
* 删除离职职工：按照编号删除指定的职工
* 修改职工信息：按照编号修改职工个人信息
* 查找职工功能：查找某位员工
* 按照编号排序：按照职工编号，进行排序，排序规则由用户指定
* 清空所有文档：清空文件中记录的所有职工信息（清空前需要再次确认，防止误删）

## 系统界面：

此时WorkManager.h的代码展示：
~~~c++
#pragma once//防止头文件重复
#include<iostream>//包含输入输出流头文件
using namespace std;//使用标准命名空间

class WorkManager {
public:
	//构造函数
	WorkManager();

	//展示菜单
	void Show_Menu();

	//析构函数
	~WorkManager();
};


~~~

此时WorkManager.cpp的代码展示
~~~C++
#include"WorkManager.h"

WorkManager::WorkManager() {

}

WorkManager::~WorkManager() {

}

//展示菜单
void WorkManager::Show_Menu(){
	cout << "******************************************" << endl;
	cout << "********* 欢迎使用职工管理系统！ *********" << endl;
	cout << "************ 0.退出管理系统 **************" << endl;
	cout << "************ 1.增加职工信息 **************" << endl;
	cout << "************ 2.显示职工信息 **************" << endl;
	cout << "************ 3.删除离职职工 **************" << endl;
	cout << "************ 4.修改职工信息 **************" << endl;
	cout << "************ 5.查找员工信息 **************" << endl;
	cout << "************ 6.按照编号排序 **************" << endl;
	cout << "************ 7.清空所有文档 **************" << endl;
	cout << "******************************************" << endl;
	cout << endl;
}


~~~

此时主函数的代码展示：
~~~c++
#include"WorkManager.h"

int main() {
	//实例化一个管理者的一个对象
	WorkManager wm;
	//调用成员菜单函数
	wm.Show_Menu();
	system("pause");
	return 0;
}
~~~


## 退出功能的实现：

### _1.提供功能接口

在main函数中提供分支选项，提供每个功能接口

代码展示：

~~~c++
void WorkerManager::exitSystem() {
	cout << "欢迎下次使用" << endl;
	system("pause");
	exit(0);//只要调用该函数程序就退出了
}
~~~

此时WorkManager.h的代码展示：
~~~c++
#pragma once//防止头文件重复
#include<iostream>//包含输入输出流头文件
using namespace std;//使用标准命名空间

class WorkManager {
public:
	//构造函数
	WorkManager();

	//展示菜单
	void Show_Menu();

	//退出功能
	void ExitSystem();

	//析构函数
	~WorkManager();
};
~~~

此时WorkManager.cpp的代码展示：
~~~c++
#include"WorkManager.h"

WorkManager::WorkManager() {

}

WorkManager::~WorkManager() {

}

//展示菜单
void WorkManager::Show_Menu(){
	cout << "******************************************" << endl;
	cout << "********* 欢迎使用职工管理系统！ *********" << endl;
	cout << "************ 0.退出管理系统 **************" << endl;
	cout << "************ 1.增加职工信息 **************" << endl;
	cout << "************ 2.显示职工信息 **************" << endl;
	cout << "************ 3.删除离职职工 **************" << endl;
	cout << "************ 4.修改职工信息 **************" << endl;
	cout << "************ 5.查找员工信息 **************" << endl;
	cout << "************ 6.按照编号排序 **************" << endl;
	cout << "************ 7.清空所有文档 **************" << endl;
	cout << "******************************************" << endl;
	cout << endl;
}

//退出功能
void WorkManager::ExitSystem() {
	cout << "欢迎下次使用" << endl;
	system("pause");
	exit(0);//退出程序
}
~~~

此时主函数的代码展示
~~~C++
#include"WorkManager.h"

int main() {
	//实例化一个管理者的一个对象
	WorkManager wm;
	int choice;
	while (true) {
		wm.Show_Menu();
		cout << "请输入你的选择：" << endl;
		cin >> choice;
		switch (choice)
		{
		case 0://退出系统
			wm.ExitSystem();
			break;
		case 1://增加职工

			break;
		case 2://显示职工
			break;
		case 3://删除职工
			break;
		case 4://修改职工
			break;
		case 5://查找职工
			break;
		case 6://排序职工
			break;
		case 7://清空文件
			break;
		default:
			system("cls");
			break;
		}
	}
	//调用成员菜单函数
	wm.Show_Menu();
	system("pause");
	return 0;
}
~~~


## 创建职工类

_1.创建职工抽象类：
职工的分类：普通员工，经理，老板
将三种职工抽象的一个类(work)中，利用多态管理不同职工种类
职工的属性为：职工编号，职工姓名，职工所在部门编号
职工的行为为：敢为职责信息描述，获取岗位名称

创建worker.h文件并且添加如下代码：

~~~c++
#pragma once
#include<iostream>
#include<string>
using namespace std;

class Worker {
public:
	//显示个人信息
	virtual void showInfo() = 0;

	//获取岗位名称
	virtual string getDeptName() = 0;

	int m_Id;//职工编号
	string m_Name;//职工姓名
	int m_DeptId;//职工所在部门
};
~~~



### 创建普通员工类：
普通员工类继承职工抽象类，并重写父类中的纯虚函数
在头文件和源文件的文件夹下分别创建employee.h和employee.cpp

employee.h中代码如下：
~~~c++
#pragma once
#include"worker.h"

class Employee:public Worker {
public:
	Employee(int id, string name, int deptid);

	//展示个人信息
	void showInfo();

	//获取岗位名称
	string getDeptName();

};
~~~

employee.cpp中代码如下：
~~~c++
#include"employee.h"

Employee::Employee(int id, string name, int deptid) {
	m_Id = id;
	m_Name = name;
	m_DeptId = deptid;
}

void Employee::showInfo() {
	cout << "职工编号：" << this->m_Id
		<< "/t职工编号：" << this->m_Name
		<< "/t岗位：" << this->getDeptName() << endl;
}

string Employee::getDeptName() {
	return string("员工");
}
~~~



### 创建经理类：

经理继承职工抽象类，并重写父类中纯虚函数，和普通员工类似
在头文件和源文件的文件夹下分别创建manager.h和manager.cpp文件

manager.h中代码如下：
~~~c++
#pragma once
#include"worker.h"

class Manager:public Worker {
public:

	Manager(int id, string name, int deptid);
	
	void showInfo();

	string getDeptId();

	int m_Id;
	string m_Name;
	int m_DeptId;
};
~~~

manager.cpp中代码如下：
~~~c++
#include"manager.h"

Manager::Manager(int id, string name, int deptid) {
	this->m_Id = id;
	this->m_Name = name;
	this->m_DeptId = deptid;
}

void Manager::showInfo() {
	cout << "职工编号：" << this->m_Id
		<< "\t职工姓名：" << this->m_Name
		<< "\t岗位：" << getDeptName()
		<< "\t岗位职责：完成老板交给的任务，并下发任务给员工" << endl;
}

string Manager::getDeptId() {
	return string("经理");
}
~~~



### 创建老板类：

老板类继承职工抽象类，并重写父类中纯虚函数，和普通员工类似
在头文件和源文件中分别创建boss.h和boss.cpp

boss.h中代码如下：
~~~c++
#pragma once
#include"worker.h"

class Boss :public Worker {
public:
	Boss(int id, string name, int deptid);

	void showInfo();

	string getDeptId();

	int m_Id;
	string m_Name;
	int m_DeptId;
};
~~~

boss.cpp中代码如下：
~~~c++
#include"boss.h"

Boss::Boss(int id, string name, int deptid) {
	this->m_Id = id;
	this->m_DeptId = deptid;
	this->m_Name = name;
}

void Boss::showInfo() {
	cout << "\t职工编号：" << this->m_Id
		<< "\t职工姓名：" << this->m_Name
		<< "\t岗位：" << this->getDeptId()
		<< "岗位职责：管理公司所有事务" << endl;
}

string Boss::getDeptId() {
	return string("老板");
}
~~~




## 添加职工
功能描述：批量添加职工，并且保存到文件中

### 功能描述
分析：
用户在批量创建时，可能会创建不同种类的职工
如果想将所有不同种类的员工都放入到一个数组中，可以将所有员工的指针维护放到一个数组中
如果想在程序中维护这个不定长度的数组，可以将数组创建到堆区，并利用Worker**的指针维护

### 功能实现
在WorkManager.h头文件中添加成员属性 代码：
~~~c++
int m_EmpNum;

Worker** m_EmpArray;
~~~

在WorrManager.cpp构造函数中初始化属性：
~~~c++
WorkManager::WorkManager(){
	//初始化人数：
	this->m_EmpNum = 0;
	
	//初始化数组指针：
	this->m_EmpArray = NULL;
}
~~~

在WorkManager.h中添加成员函数
~~~c++
//增加职工
void Add_Emp();
~~~

WorkManager中实现该函数
~~~c++
//增加职工
void WorkManager::Add_Emp() {
	cout << "请输入增加职工数量：" << endl;

	int addNum = 0;
	cin >> addNum;
	if (addNum > 0) {
		//添加
		//计算添加新空间的大小
		int newSize = this->m_EmpNum + addNum;

		//开辟新空间
		Worker** newSpace = new Worker*[newSize];

		//将原来空间下的数据，拷贝到新空间下
		if (this->m_EmpArray != NULL) {
			for (int i = 0; i < this->m_EmpNum; i++) {
				newSpace[i] = this->m_EmpArray[i];
			}
		}
		
		//批量添加新数据
		for (int i = 0; i < addNum; i++) {
			int id;//职工编号
			string name;//职工姓名
			int dSelect;//部门选择
			
			cout << "请输入第" << i + 1 << "个新职工的编号：" << endl;
			cin >> id;

			cout << "请输入第" << i + 1 << "个新职工的姓名：" << endl;
			cin >> name;

			cout << "请选择该职工的岗位：" << endl;
			cout << "1.普通职工" << endl;
			cout << "2.经理" << endl;
			cout << "3.老板" << endl;
			cin >> dSelect;

			Worker* worker = NULL;
			switch (dSelect)
			{
			case 1:
				worker = new Employee(id, name, 1);
				break;
			case 2:
				worker = new Manager(id, name, 2);
				break;
			case 3:
				worker = new Boss(id, name, 3);
				break;
			default:
				break;
			}

			//将创建职工职责，保存到数组中
			newSpace[this->m_EmpNum + i] = worker;

			//释放原有空间
			delete[] this->m_EmpArray;

			//更新新空间指向
			this->m_EmpArray = newSpace;

			//更新新的职工人数
			this->m_EmpNum = newSize;

			//提示添加成功
			cout << "成功添加" << addNum << "名新职工" << endl;
		}
	}
	else {
		//输入有误
		cout << "输入数据有误" << endl;
	}

	//按任意键后 清屏回到上级目录
	system("pause");
	system("cls");
}

~~~

补充代码：
~~~c++
WorkManager::~WorkManager() {
	if (this->m_EmpArray != NULL) {
		delete this->m_EmpArray;
		this->m_EmpArray = NULL;
	}
}//堆区数据手动开辟手动释放
~~~

![image-20220514225533472](职工管理系统.assets/image-20220514225533472.png)



## 文件交互-写文件

功能描述：对文件进行读写
咋上一个添加功能中，我们只是将所有的数据添加到了内存中，一旦程序结束就无法保存了
因此文件管理类中需要一个与文件进行交互的功能，对于文件进行读写操作

### 设定文件路径
首先我们将文件路径，再WorkManager.h添加宏常量，并且包含头文件fstream
~~~c++
#include<fstream>
~~~

### 成员函数声明
在WorkManager.h中类添加成员函数 void save()
~~~c++
//保存文件
void save();
~~~

### 保存文件功能实现
~~~c++
//保存文件功能
void WorkManager::save() {
	ofstream ofs;
	ofs.open(FILENAME, ios::out);

	//将每个人数据写入到文件中
	for (int i = 0; i < this->m_EmpNum; i++) {
		ofs << this->m_EmpArray[i]->m_Id << " "
			<< this->m_EmpArray[i]->m_Name << " "
			<< this->m_EmpArray[i]->m_DeptId << " "
			<< endl;
	}

	//关闭文件
	ofs.close();
}
~~~



## 文件交互-读文件
功能描述：将文件中的内容读取到程序中
虽然我们实现了添加职工后保存到文件的操作，但是每次开始运行程序，并没有将文件中数据读取到程序中
而我们的程序功能还有清空文件的需求
因此构造函数初始化数据的情况分为三种

1. 第一次使用，文件未创建
2. 文件存在，但是数据被用户清空
3. 文件存在，而且保存职工的所有数据





### 文件未创建

在WorkManager.h中添加新的成员属性m_FilelsEmpty标志文件是否为空
~~~c++
	//标志文件是否为空的标志
	bool m_FileIsEmpty;
~~~

修改WorkManager.cpp中构造函数代码
~~~c++
WorkManager::WorkManager() {
	//1.文件不存在
	ifstream ifs;
	ifs.open(FILENAME, ios::in);//读文件

	if (!ifs.is_open()/*没有打开成功*/) {
		cout << "文件不存在" << endl;
		//初始化属性
		//初始化记录人数
		this->m_EmpArray = NULL;
		//初始化数组指针
		this->m_EmpNum = 0;
		//初始化文件是否为空
		this->m_FileIsEmpty = true;
		ifs.close();
		return;
	}
}
~~~
删除文件后，测试文件不存在时初始化数据功能




### 文件存在且数据为空
在WorkManager.cpp中的构造函数追加代码
~~~c++
//文件存在，并且没有记录
	char ch;
	ifs >> ch;
	if (ifs.eof()) {
		cout << "文件为空！" << endl;
		this->m_EmpArray = NULL;
		this->m_EmpNum = NULL;
		this->m_FileIsEmpty = true;
		ifs.close();
		return;
	}
	//eof()是判断ifs是否读取到了文件结束符，读取到为true。创建ch，让ifs进行一次输出到临时变量ch，若ch读取的字符       为空，那么ifs接下来就指向文件结束符。eof()为true
~~~
将文件创建后清空文件内容，并测试该情况下初始化功能

我们发现文件不存在或者为空m_FileIsEmpty判断文件是否为空的标志都为真，那何时为假？
成功添加职工后，应该更改文件不为空的标志
在``void WorkManager::Add_Emp()``成员中添加：
~~~c++
//更新职工不为空标志
this->m_FileIsEmpty = false;
~~~





### 文件存在且保存职工数据
#### 获取记录的职工人数
在WorkManager.h中添加成员函数```int get_EmpNum();```
~~~c++
//统计人数
int get_EmpNum();
~~~

WorkManager.cpp中实现
~~~c++
//统计人数
int WorkManager::get_EmpNum() {
	ifstream ifs;
	ifs.open(FILENAME, ios::in);

	int id;
	string name;
	int dId;

	int num = 0;

	while (ifs >> id && ifs >> name && ifs >> dId) {
		//记录人数
		num++;
	}
	ifs.close();

	return num;
}
~~~


第三种情况：
文件存在，且不为空
~~~c++
	//3.文件存在，并且记录数据
	int num = this->get_EmpNum();
	cout << "职工人数为：" << num << endl;
	this->m_EmpNum = num;
~~~




### 初始化数组
根据职工的数据以及职工数据，初始化WorkManager中的Worker** m_EmpArray指针

在WorkManager.h中添加成员函数```void init_Emp();```

~~~c++
//初始化员工
void init_Emp();
~~~

在WorkManager.cpp中实现
~~~c++
//初始化员工
void WorkManager::init_Emp() {
	ifstream ifs;
	ifs.open(FILENAME, ios::in);

	int id;
	string name;
	int dId;

	int index = 0;

	while (ifs >> id && ifs >> name && ifs >> dId) {
		Worker* worker = NULL;
		if (dId == 1) {//普通职工
			worker = new Employee(id, name, dId);
		}
		else if (dId == 2) {//经理
			Worker* worker = new Manager(id, name, dId);
		}
		else {
			Worker* worker = new Boss(id, name, dId);
		}
		this->m_EmpArray[index] = worker;
		index++;
	}

	//关闭文件
	ifs.close();


}
~~~




## 显示职工
功能描述：显示当前所有职工信息
### 显示职工函数声明
在WorkManager.h中添加成员函数```void show_Emp();```
~~~c++
//显示职工
void Show_Emp();
~~~


### 显示职工函数实现
在WorkManager.cpp中实现成员函数```void Show_Emp();```
~~~c++
//显示职工

~~~

